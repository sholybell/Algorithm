package com.holybell.algorithm.binarysearch;

import com.holybell.algorithm.common.util.ArrayUtil;

/**
 * 难度:中等
 * <p>
 * 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
 * 每行中的整数从左到右按升序排列。
 * 每行的第一个整数大于前一行的最后一个整数。
 * <p>
 * <p>
 * 示例 1：
 * 输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
 * 输出：true
 * <p>
 * <p>
 * 示例 2：
 * 输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
 * 输出：false
 * <p>
 * <p>
 * 提示：
 * m == matrix.length
 * n == matrix[i].length
 * 1 <= m, n <= 100
 * -104 <= matrix[i][j], target <= 104
 * <p>
 * Related Topics 数组 二分查找
 */
public class LeetCode74_searchMatrix {

    public boolean searchMatrix(int[][] matrix, int target) {
        return false;
    }

    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------

    /**
     * 先定位target可能在的行，然后对改行进行二分查找
     */
    public boolean searchMatrixV1(int[][] matrix, int target) {

        // 二维矩阵中第一个元素最小，但是还是大于target，表示target不存在二维矩阵
        if (matrix[0][0] > target) {
            return false;
        }

        int rows = matrix.length, cols = matrix[0].length;

        // target比二维矩阵最大的值还大，肯定不存在二维矩阵
        if (matrix[rows - 1][cols - 1] < target) {
            return false;
        }

        // 假定target存在二维矩阵，那么target一定存在某一行，存在 matrix[row][0]<=target<=maxtrix[row][cols-1]

        // 查找target可能存在的行
        int targetRow = -1;
        for (int row = 0; row < rows; row++) {

            // target刚好是某一行的头尾元素
            if (matrix[row][0] == target) {
                return true;
            }
            if (matrix[row][cols - 1] == target) {
                return true;
            }

            // 每一行判断最后一个元素是否大于target，当前行最后一个元素大于target，表示如果target存在，一定在当前行
            if (matrix[row][cols - 1] > target) {
                targetRow = row;
                break;
            }
        }

        // 在行中二分查找target是否存在
        int begin = 0, end = cols - 1;
        while (begin <= end) {
            int mid = begin + (end - begin) / 2;
            if (matrix[targetRow][mid] == target) {
                return true;
            } else if (matrix[targetRow][mid] > target) {   // 收缩上边界
                end = mid - 1;
            } else if (matrix[targetRow][mid] < target) {   // 收缩下边界
                begin = mid + 1;
            }
        }

        return false;
    }

    public static void main(String[] args) {

        LeetCode74_searchMatrix searchMatrix = new LeetCode74_searchMatrix();

        int[][] matrix1 = new int[][]{
                {1, 3, 5, 7},
                {10, 11, 16, 20},
                {23, 30, 34, 60}
        };

        System.out.println("二维矩阵如下:");
        ArrayUtil.printBoard(matrix1);
        System.out.println("你的答案:");
        System.out.println("二维矩阵是否存在3 : " + searchMatrix.searchMatrix(matrix1, 3));
        System.out.println("二维矩阵是否存在13 : " + searchMatrix.searchMatrix(matrix1, 13));
        System.out.println("------------------------------>");
        System.out.println("正确答案:");
        System.out.println("二维矩阵是否存在3 : " + searchMatrix.searchMatrixV1(matrix1, 3));
        System.out.println("二维矩阵是否存在13 : " + searchMatrix.searchMatrixV1(matrix1, 13));
    }
}

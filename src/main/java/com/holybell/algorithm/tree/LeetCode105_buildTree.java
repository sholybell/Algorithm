package com.holybell.algorithm.tree;

import com.holybell.algorithm.common.TreeNode;
import com.holybell.algorithm.common.util.TreeUtil;

import java.util.Optional;

/**
 * 难度：中等
 * <p>
 * 已知一棵二叉树的前序遍历、中序遍历，求它的后序遍历
 * <p>
 * 你可以假设树中没有重复的元素。
 */
public class LeetCode105_buildTree {

    private static TreeNode _buildTree(int[] preorder, int[] inorder) {
        return null;
    }

    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------

    /**
     * 由前序和中序遍历构建一颗二叉树
     *
     * @param preOrder 前序遍历
     * @param inOrder  中序遍历
     * @return 二叉树的根节点
     */
    private static TreeNode buildTree(int[] preOrder, int[] inOrder) {
        return helper(preOrder, 0, preOrder.length - 1, inOrder, 0, inOrder.length - 1);
    }

    /**
     * 递归辅助计算
     *
     * @param preOrder      前序遍历
     * @param preOrderStart 前序遍历头指针
     * @param preOrderEnd   前序遍历尾指针
     * @param inOrder       中序遍历
     * @param inOrderStart  中序遍历头指针
     * @param inOrderEnd    中序遍历尾指针
     * @return 每次递归的子二叉树头结点
     */
    private static TreeNode helper(int[] preOrder, int preOrderStart, int preOrderEnd, int[] inOrder, int inOrderStart, int inOrderEnd) {

        // 前序遍历和后续遍历只要有一个头指针和尾指针错位，那么表示本次递归结束
        if (preOrderStart > preOrderEnd || inOrderStart > inOrderEnd) {
            return null;
        }

        // ----------------------------- 类似二叉树的前序遍历操作部分 开始

        // 得到本次递归的子二叉树根节点
        int rootVal = preOrder[preOrderStart];
        TreeNode root = new TreeNode(rootVal);
        // 检索这个头结点在中序遍历中的位置
        int index = findIndexInOrder(inOrder, rootVal);
        // 计算偏移量，root是本次子二叉树的根节点，根据二叉树的中序遍历头结点位置，左右元素各自为这个根节点的左右子节点，此处计算得到左子树应该有多少个元素(不包含前序遍历的头结点)
        int offset = index - inOrderStart - 1;

        // ----------------------------- 类似二叉树的前序遍历操作部分 结束

        // 计算左右子节点，类似二叉树的左右子节点遍历操作
        TreeNode left = helper(preOrder, preOrderStart + 1, preOrderStart + 1 + offset, inOrder, inOrderStart, index - 1);
        TreeNode right = helper(preOrder, preOrderStart + 1 + offset + 1, preOrderEnd, inOrder, index + 1, inOrderEnd);

        root.left = left;
        root.right = right;
        return root;
    }

    /**
     * 遍历中序遍历，查询给定值的下标（由于假定不存在重复的元素）
     *
     * @param inOrder 中序遍历
     * @param val     目标值
     * @return 目标值索引
     */
    private static int findIndexInOrder(int[] inOrder, int val) {
        for (int i = 0; i < inOrder.length; i++) {
            if (inOrder[i] == val) {
                return i;
            }
        }
        return -1;
    }


    public static void main(String[] args) {
        int[] preOrder = {1, 2, 4, 8, 9, 5, 10, 3, 6, 7};
        int[] inOrder = {8, 4, 9, 2, 10, 5, 1, 6, 3, 7};
        System.out.println("你的答案:");
        TreeNode root = _buildTree(preOrder, inOrder);
        if (Optional.ofNullable(root).isPresent()) {
            TreeUtil.show(root);
        }
        System.out.println("=================================");
        System.out.println("正确答案:");
        root = buildTree(preOrder, inOrder);
        TreeUtil.show(root);

    }
}

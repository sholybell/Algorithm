package com.holybell.algorithm.list;

import java.util.Arrays;
import java.util.Deque;
import java.util.LinkedList;

/**
 * 难度：困难
 * <p>
 * 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。
 * 你只可以看到在滑动窗口 k 内的数字。
 * 滑动窗口每次只向右移动一位。
 * 返回滑动窗口最大值。
 * <p>
 * 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7] 解释: leetCode 239
 */
public class Question009_MaxSlidingWindow {


    /**
     * @param nums 给定数组
     * @param k    窗口的长度
     */
    private static int[] myMaxSlidingWindow(int[] nums, int k) {

        return null;
    }

    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------

    private static int[] maxSlidingWindow(int[] nums, int k) {

        // 如果给定数组为null，或者给定数组就没有达到窗口长度返回null
        if (nums == null || nums.length < k) {
            return null;
        }

        // 双端队列，存储窗口的下标
        Deque<Integer> dq = new LinkedList<>();
        // 保存最后返回的结果
        int[] results = new int[nums.length - k + 1];

        // 每一次循环代表窗口往右移动一位
        for (int i = 0; i < nums.length; i++) {

            // 队列头部存储的是上一个窗口的最大值下标
            // 每次窗口往右边移动，校验队列尾部的元素是否不大于当前元素，满足则将尾部元素弹出
            // 这里的关注点有：
            // 1. 这是个循环，如果窗口移动之后新加入的元素大于前面窗口的所有元素，那么前面队列将被清空
            // 2. 如果当前元素大于队列尾部元素，说明这个窗口的最大元素肯定不会是队列尾部元素，可以把队列尾部的元素淘汰出去
            // 3. 如果当前元素小于队列尾部的元素，队列尾部的元素是不需要弹出的，因为不知道窗口移动之后，需要加入的这个更小的元素是否会在某次移动变成窗口最大元素
            while (!dq.isEmpty() && nums[dq.peekLast()] <= nums[i]) {
                dq.pollLast();
            }

            // 将当前元素下标加入到队列尾部
            dq.addLast(i);

            // 队列首部的存储的下标是队列内部最小的(也是上次窗口中最大值的下标)，判断本次移动之后队列头部元素是否超出本窗口长度，要弹出
            if (dq.peek() <= i - k) {
                dq.poll();
            }

            // 当前遍历的下标达到了窗口长度，可以开始选择窗口内最大的元素
            if (i + 1 >= k) {
                results[i + 1 - k] = nums[dq.peek()];
            }
        }
        return results;
    }

    public static void main(String[] args) {
//        int[] a1 = {1, 3, -1, -3, 5, 3, 6, 7};
//        System.out.println(Arrays.toString(maxSlidingWindow(a1, 3)));

        int[] a2 = {1, 3, -1, -3, 5, 3, 6, 7};
        System.out.println("[3, 3, 5, 5, 6, 7]".equals(Arrays.toString(myMaxSlidingWindow(a2, 3)))
                ? Arrays.toString(myMaxSlidingWindow(a2, 3)) + " √"
                : Arrays.toString(myMaxSlidingWindow(a2, 3)) + " ×");
    }
}

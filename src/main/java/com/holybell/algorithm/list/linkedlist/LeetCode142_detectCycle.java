package com.holybell.algorithm.list.linkedlist;

import com.holybell.algorithm.common.ListNode;
import com.holybell.algorithm.common.util.ListUtil;

import java.util.HashSet;
import java.util.Set;

/**
 * 难度:中等
 * <p>
 * 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
 * <p>
 * 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。
 * 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。
 * <p>
 * 说明：不允许修改给定的链表。
 * <p>
 * 进阶：
 * 你是否可以使用 O(1) 空间解决此题？
 * <p>
 * 示例 1：
 * 输入：head = [3,2,0,-4], pos = 1
 * 输出：返回索引为 1 的链表节点
 * 解释：链表中有一个环，其尾部连接到第二个节点。
 * <p>
 * 示例 2：
 * 输入：head = [1,2], pos = 0
 * 输出：返回索引为 0 的链表节点
 * 解释：链表中有一个环，其尾部连接到第一个节点。
 * <p>
 * 示例 3：
 * 输入：head = [1], pos = -1
 * 输出：返回 null
 * 解释：链表中没有环。
 * <p>
 * 提示：
 * 链表中节点的数目范围在范围 [0, 104] 内
 * -105 <= Node.val <= 105
 * pos 的值为 -1 或者链表中的一个有效索引
 */
public class LeetCode142_detectCycle {

    private static ListNode _detectCycle(ListNode head) {
        return null;
    }

    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------

    /**
     * 检测一个链表是否存在环，如果存在环返回环的起点，如果不存在，返回null
     * <p>
     * 本方法为进阶，O(1)空间复杂度
     *
     * @param head 链表头节点
     */
    private static ListNode detectCycle(ListNode head) {

        // 链表头节点为null，直接返回null
        if (head == null) {
            return null;
        }

        boolean hasCycle = false;

        // 首先使用快慢指针判断是否存在环
        ListNode fast = head, slow = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            // 存在环
            if (slow == fast) {
                hasCycle = true;
                break;
            }
        }

        // 存在环，寻找环的起点
        if (hasCycle) {

            // 本解法最难理解的部分在于此:为什么将其中任何一个节点挪回链表头节点，快慢指针按相同速率往前走，再次相遇就是环的起点!!!!!!!!!!
            // 以下面一个链表图形来举例:
            // 1  -  2  -  3  -  4  -  5  -  6  -  7  -  8
            //                         |                 |
            //                         12 -  11 - 10  -  9
            // 由于fast指针每次走两步，slow指针每次走一步，存在环的情况下，二者相遇时，一定存在fast走了2k步，slow走了k步!!!!
            // 假定环外长度 a，快慢指针在环内距离环起点的m点相遇， 2k - k 这个公式扣除的部分包括，慢指针走的a，以及在环内走的m，以及剩下的n个环长度，
            // 由此得到的2k-k=k，剩下的k一定是环的整数倍!!!!!
            // ----------------------
            // 在环内走k-m步到环起点分析:
            // 既然可以知道k是环的整数倍，那么既然相遇点距离环起点m，那么移动k-m之后一定是环的起点（假定已经从起点走了m步，那么再走k-m步刚好是环的整数倍，那就是起点）
            //
            // 从链表头指针走k-m步到环起点分析：
            // 由于慢指针从头指针到与快快指针在环内相遇，那么k一定满足 k = a + n(环)+ m，那么从头结点走 k-m 一定会经过在环内绕n个圈之后走到头结点
            //
            // 由此可知: 若链表存在环，则从快慢指针相遇点走k-m，以及从链表头指针走k-m都能够到环起点，那么接下来只需要将快慢指针一个挪回头结点，一个还在相遇点，
            // 二者同速率往前走，一定会在一个相同的步数情况下在环起点相遇!!!!!!!!!!!!!!!!!!!

            slow = head;
            while (slow != fast) {
                slow = slow.next;
                fast = fast.next;
            }
            return slow;
        }

        // 不存在环
        return null;
    }

    /**
     * 检测一个链表是否存在环，如果存在环返回环的起点，如果不存在，返回null
     * <p>
     * 类似{@link LeetCode142_detectCycle}，使用Set遍历每个节点重复的节点即为环的起点
     *
     * @param head 链表头节点
     */
    private static ListNode detectCycleV2(ListNode head) {

        // 链表头节点为null，直接返回null
        if (head == null) {
            return null;
        }

        Set<ListNode> nodeCache = new HashSet<>();
        while (head != null) {
            // 将节点加入缓存中，如果加入失败表示存在重复节点
            if (nodeCache.add(head)) {
                head = head.next;
            } else {
                return head;
            }
        }

        // 不存在环
        return null;
    }

    public static void main(String[] args) {
        ListNode head = ListUtil.createCycleLinkedList(new int[]{3, 2, 0, -4}, 1);
        System.out.println("你的答案:");
        ListNode target = _detectCycle(head);
        System.out.println("环的起点节点位于链表索引(0开始):" + ListUtil.findIndexByValue(head, target));
        System.out.println("---------------------------->");
        System.out.println("正确答案:");
        target = detectCycle(head);
        System.out.println("环的起点节点位于链表索引(0开始):" + ListUtil.findIndexByValue(head, target));
    }
}

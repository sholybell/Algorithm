package com.holybell.algorithm.list.linkedlist;

import com.holybell.algorithm.common.ListNode;
import com.holybell.algorithm.common.util.ListUtil;

import java.util.HashMap;
import java.util.Map;

/**
 * 难度:中等
 * <p>
 * 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
 * <p>
 * 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
 * <p>
 * <p>
 * <p>
 * 示例 1：
 * 输入：head = [1,2,3,4]
 * 输出：[2,1,4,3]
 * <p>
 * <p>
 * 示例 2：
 * 输入：head = []
 * 输出：[]
 * <p>
 * <p>
 * 示例 3：
 * 输入：head = [1]
 * 输出：[1]
 * <p>
 * <p>
 * 提示：
 * <p>
 * <p>
 * 链表中节点的数目在范围 [0, 100] 内 0 <= Node.val <= 100
 * <p>
 * <p>
 * 进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）
 * <p>
 * <p>
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
public class LeetCode24_swapPairs {

    private static ListNode mySwapPairs(ListNode head) {
        return null;
    }

    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------

    /**
     * 递归解法
     */
    private static ListNode swapPairsV1(ListNode head) {

        // 头结点为空，或者仅有头结点直接返回头结点
        if (head == null || head.next == null) {
            return head;
        }

        ListNode newHead = head.next;           // 每一次递归处理两个节点，可以当做一个子串，这个子串的新头结点为入参节点的后一个节点
        head.next = swapPairsV1(newHead.next);  // 递归计算下一个两两子串的头结点
        newHead.next = head;                    // 將新头结点的后继节点指向入参节点，逆转两个节点的指向
        return newHead;                         // 返回本次子串的头结点
    }

    // ---------------------------------------------------------------------------------------------------

    /**
     * 迭代解法
     */
    private static ListNode swapPairsV2(ListNode head) {

        if (head == null || head.next == null) {
            return head;
        }

        // 使用一个空节点指向头结点
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        ListNode newHead = head.next;

        while (dummy.next != null && dummy.next.next != null) {
            ListNode node1 = dummy.next;            // 两两节点中前一个节点
            ListNode node2 = dummy.next.next;       // 两两节点中后一个节点

            ListNode tmp = node2.next;
            node2.next = node1;                     // 后一个节点指向前一个
            node1.next = tmp;                       // 前一个节点指向后一个节点的后继节点
            dummy.next = node2;                     // 记得将dummy节点指向本次两两节点的后置节点
            dummy = node1;                          // 空节点再次指向下一批要处理的两两节点的前一个节点位置
        }
        return newHead;
    }


    // ---------------------------------------------------------------------------------------------------

    /**
     * 借助额外的空间，记录链表的每个节点位置
     */
    private static ListNode swapPairsV3(ListNode head) {

        if (head == null || head.next == null) {
            return head;
        }

        Map<Integer, ListNode> map = new HashMap<>();
        int count = 0;
        while (head != null) {
            map.put(count++, head);
            head = head.next;
        }

        int size = map.size() / 2;  // 需要两两转换次数
        for (int i = 0; i < size; i++) {
            ListNode pre = map.get(i * 2);
            ListNode after = map.get(i * 2 + 1);

            // 记录交换之后的头结点
            if (i * 2 + 1 == 1) {
                head = after;
            }

            ListNode tmp = after.next;
            after.next = pre;
            pre.next = tmp;

            // 将前一轮交换的两个节点的原前继节点指向当前交换之后的前一个节点
            if (i != 0) {
                ListNode last = map.get(i * 2 - 2);
                last.next = after;
            }
        }
        return head;
    }


    public static void main(String[] args) {
        ListUtil.createLinkedList(new int[]{1, 2, 3, 4, 5});
        System.out.println("你的答案:" + ListUtil.printLinkedList(mySwapPairs(ListUtil.createLinkedList(new int[]{1, 2, 3, 4, 5}))));
        System.out.println("-------------------------->");
        System.out.println("正确答案:" + ListUtil.printLinkedList(swapPairsV2(ListUtil.createLinkedList(new int[]{1, 2, 3, 4, 5}))));
    }
}

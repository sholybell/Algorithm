package com.holybell.algorithm.list.linkedlist;

import com.holybell.algorithm.common.ListNode;
import com.holybell.algorithm.common.util.ListUtil;

import java.util.HashSet;
import java.util.Set;

/**
 * 难度:简单
 * <p>
 * 反转一个单链表。
 * <p>
 * 示例:
 * <p>
 * 输入: 1->2->3->4->5->NULL
 * 输出: 5->4->3->2->1->NULL
 * <p>
 * 进阶:
 * 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？
 * <p>
 * <p>
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
public class LeetCode206_reverseList {

    private static ListNode myReverseList(ListNode head) {
        return null;
    }

    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------

    /**
     * 递归解法
     *
     * @param head 头结点
     */
    private static ListNode reverseListV1(ListNode head) {
        if (head == null) {
            return null;
        }
        return helper(head, null);   // 头结点不存在前继节点
    }

    /**
     * 辅助方法
     *
     * @param curNode 当前遍历的节点
     * @param preNode 当前节点的前继节点
     */
    private static ListNode helper(ListNode curNode, ListNode preNode) {
        // 遍历到链表的尾部，
        if (curNode == null) {
            return preNode;                 // 当前节点为null时，前继节点则为反转链表的头结点
        }

        ListNode nextNode = curNode.next;
        curNode.next = preNode;             // 当前节点的指向前继节点
        return helper(nextNode, curNode);    // 接着处理后面一个节点
    }

    /**
     * 迭代的方式逆转链表
     */
    private static ListNode reverseListV2(ListNode head) {

        if (head == null) {
            return null;
        }

        ListNode curNode = head;
        ListNode preNode = null;

        while (curNode.next != null) {
            // 获取当前节点的后继节点
            ListNode tmp = curNode.next;
            // 将后继节点指向前继节点
            curNode.next = preNode;
            // 为下一轮循环赋值新的前继节点
            preNode = curNode;
            // 为下一轮循环赋值新的要处理的节点
            curNode = tmp;
        }
        // 由于上述循环并不处理最后一个节点，因此特别处理最后一个节点，将其指向前继节点
        curNode.next = preNode;
        return curNode;
    }


    public static void main(String[] args) {
        ListUtil.createLinkedList(new int[]{1, 2, 3, 4, 5});
        System.out.println("你的答案:" + ListUtil.printLinkedList(myReverseList(ListUtil.createLinkedList(new int[]{1, 2, 3, 4, 5}))));
        System.out.println("-------------------------->");
        System.out.println("正确答案1:" + ListUtil.printLinkedList(reverseListV1(ListUtil.createLinkedList(new int[]{1, 2, 3, 4, 5}))));
        System.out.println("正确答案2:" + ListUtil.printLinkedList(reverseListV2(ListUtil.createLinkedList(new int[]{1, 2, 3, 4, 5}))));
    }
}

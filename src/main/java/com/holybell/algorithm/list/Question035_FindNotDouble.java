package com.holybell.algorithm.list;

/**
 * 难度：中等
 * <p>
 * 查找数组中出现奇数次数的元素，除了该元素，其他元素都出现偶数次数
 */
public class Question035_FindNotDouble {

    /**
     * 异或法:
     * 根据异或定义可知，任何一个数字异或自己都等于0，所以，如果从头到尾依次异或数组中每一个数字，
     * 那么出现两次的数字将会在异或过程中抵消掉，最终结果刚好是这个只出现一次的数字。
     *
     * @param a 给定数组
     */
    private static int myFindNotDoubleV1(int a[]) {
        return -1;
    }

    /**
     * 比特法:
     * 异或法只能用于在出现偶数次数的数组里面查询出现奇数次数的某个元素，
     * 若将题目条件放宽，数组内除了某个元素都出现过N次，N可以为奇数和偶数，那么求没有出现N次的那个元素
     *
     * @param a           给定数组
     * @param appearTimes 出现次数
     */
    private static int myFindNotDoubleV2(int a[], int appearTimes) {

        return -1;
    }

    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------

    /**
     * 异或法:
     * 根据异或定义可知，任何一个数字异或自己都等于0，所以，如果从头到尾依次异或数组中每一个数字，
     * 那么出现两次的数字将会在异或过程中抵消掉，最终结果刚好是这个只出现一次的数字。
     *
     * @param a 给定数组
     */
    private static int findNotDoubleV1(int a[]) {
        // 以下情况不处理
        if (a == null || a.length == 0) {
            return Integer.MIN_VALUE;
        }

        int result = a[0];
        for (int i = 1; i < a.length; i++) {
            result = result ^ a[i];
        }
        return result;
    }

    /**
     * 比特法:
     * 异或法只能用于在出现偶数次数的数组里面查询出现奇数次数的某个元素，
     * 若将题目条件放宽，数组内除了某个元素都出现过N次，N可以为奇数和偶数，那么求没有出现N次的那个元素
     *
     * @param a           给定数组
     * @param appearTimes 出现次数
     */
    private static int findNotDoubleV2(int a[], int appearTimes) {

        //  以下情况不处理
        if (a == null || a.length == 0 || appearTimes <= 0 || appearTimes > a.length) {
            return Integer.MIN_VALUE;
        }

        // 使用一个32长度的数组，每个数组位置标示int的bit位置为1的次数
        int[] bitCount = new int[32];

        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < 32; j++) {  // 一个int类型32长度
                if (((a[i] >> j) & 1) == 1) {   // 判断当前元素的j位置是否为1，是的话bitCount[j]++
                    bitCount[j]++;
                }
            }
        }

        int result = 0;  // 注意初始值，要累加的

        for (int i = 0; i < 32; i++) {
            // 如果数组内都出现appearTime次，那么比特数组的每一位都应该能够被appearTime整除，不能整除说明这个位置被出现次数不为appearTimes的元素累计过
            if (bitCount[i] % appearTimes != 0) {
                result = result + (1 << i);
            }
        }
        return result;
    }

    public static void main(String[] args) {
        int a[] = {1, 2, 3, 2, 4, 3, 5, 4, 1};
        System.out.println("正确答案(异或法):" + findNotDoubleV1(a));
        System.out.println("正确答案(比特法):" + findNotDoubleV2(a, 2));
        System.out.println("-------------->");
        System.out.println("本次答案(异或法):" + myFindNotDoubleV1(a));
        System.out.println("本次答案(比特法)" + myFindNotDoubleV2(a, 2));
    }
}

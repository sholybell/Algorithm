package com.holybell.algorithm.list;

import com.holybell.algorithm.common.Base;
import com.holybell.algorithm.sort.Question005_QuickSort;

/**
 * 难度：中等
 * <p>
 * 在一个乱序的数组中，查找最小K元素
 * <p>
 * 不使用 {@link Question028_MaxMinValueInArray} 遍历数组的形式有其他方式吗？
 */
public class Question034_FindKMin extends Base {

    private static int myFindKMin(int[] a, int k) {
        return Integer.MIN_VALUE;
    }


    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------

    /**
     * 从给定数组中查找第K个小的元素
     *
     * @param a 给定数组
     * @param k 第k小元素
     * @return 第k小元素值
     */
    private static int findKMin(int[] a, int k) {

        // 以下情况不处理
        if (a == null || a.length == 0 || k < 0 || k > a.length) {
            return Integer.MIN_VALUE;
        }

        return quickSort(a, 0, a.length - 1, k);
    }

    /**
     * 辅助方法，使用快速排序进行剪枝
     * <p>
     * {@link Question005_QuickSort}
     *
     * @param a     给定数组
     * @param start 起始坐标
     * @param end   结束坐标
     * @param k     第k小元素
     */
    private static int quickSort(int[] a, int start, int end, int k) {

        if (a == null || a.length == 0) {
            return Integer.MIN_VALUE;
        }

        // 这里不能使用大于等于，否则排序到一个元素的子数组时就会返回整形最小值
        if (start > end) {
            return Integer.MIN_VALUE;
        }

        int mid = start;
        int midValue = a[start];
        int hi = end;

        // 利用快速排序，mid如果刚好是k-1那么就不需要继续递归快排了
        while (mid < hi) {
            while (mid < hi && a[hi] > midValue) {
                hi--;
            }
            if (mid < hi) {
                swap(a, mid, hi);
                mid++;
            }
            while (mid < hi && a[mid] <= midValue) {
                mid++;
            }
            if (mid < hi) {
                swap(a, mid, hi);
                hi--;
            }
        }

        a[mid] = midValue;

        // k是从1开始的，mid从0开始的，要换算
        if (mid == k - 1) {
            return a[mid];
        } else if (mid > k - 1) {
            return quickSort(a, start, mid - 1, k);  // 注意这里用了return，返回这次递归结果，否则将仅仅返回这次调用未递归结果
        } else {
            return quickSort(a, mid + 1, end, k);  // 注意这里用了return，返回这次递归结果，否则将仅仅返回这次调用未递归结果
        }
    }

    public static void main(String[] args) {
        int a[] = {1, 5, 2, 6, 0, 8, 6};
        System.out.println("正确答案:" + findKMin(a, 4));
        System.out.println("本次解答:" + myFindKMin(a, 4));
    }
}

package com.holybell.algorithm.list;

/**
 * 难度：简单
 * <p>
 * 数组a[N],1~N-1这N-1个数放在a[N]中，其中某个数值重复一次，
 * 写一个函数，找出重复的数字，要求每个元素只能访问一次，
 * 并且不能使用辅助存储空间。
 */
public class Question036_FindDuplicate {


    /**
     * 解法2：异或法
     * <p>
     * 同个相同的数字异或为0, 其他数字与0异或不变
     * 根据以上原理，可以将数组元素互相异或一次，接着再与[1,n-1]异或一次
     *
     * @param a 给定数组
     */
    private static int myFindDuplicate(int[] a) {

        return Integer.MIN_VALUE;
    }

    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------


    // 解法1： 由于[1,n-1]连续数字之间只有一个数字重复，不可以使用额外的空间，那么可以把整个数组求和，然后依次减去[1,n-1]，剩下的即为重复数字

    // 解法3： 如果可以使用额外空间，可以考虑使用遍历一遍数组，每个值存入BitSet或者Map，判断是否存在

    /**
     * 解法2：异或法
     * <p>
     * 同个相同的数字异或为0, 其他数字与0异或不变
     * 根据以上原理，可以将数组元素互相异或一次，接着再与[1,n-1]异或一次
     *
     * @param a 给定数组
     */
    private static int findDuplicate(int[] a) {
        // 以下情况不处理
        if (a == null || a.length == 0) {
            return Integer.MIN_VALUE;
        }

        // 初始值为0，0与任何数异，得到那个数字
        int result = 0;
        for (int num : a) {
            result = result ^ num;
        }

        // 这个要注意临界条件，[1,n-1]
        for (int i = 1; i < a.length; i++) {
            result = result ^ i;
        }
        return result;
    }

    public static void main(String[] args) {
        int a[] = {1, 2, 1, 3, 4};

        System.out.println("正确答案:" + findDuplicate(a));
        System.out.println("本次答案" + myFindDuplicate(a));

    }
}

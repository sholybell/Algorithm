package com.holybell.algorithm.list;


import java.util.Arrays;
import java.util.Deque;
import java.util.LinkedList;

/**
 * 难度：困难
 * <p>
 * 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 k 内的数字。
 * 滑动窗口每次只向右移动一位。
 * 返回滑动窗口最大值。
 * <p>
 * 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7]
 * <p>
 * 解释: leetCode 239
 */
public class Question046_MaxSlidingWindow {

    /**
     * 给定一个数组，并且给定滑动窗口大小，窗口每次右移一位，求每次移动窗口中最大的数字
     *
     * @param a 给定数组
     * @param k 滑动窗口大小
     */
    private static int[] myMaxSlidingWindow(int[] a, int k) {
        return null;
    }

    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------

    /**
     * 给定一个数组，并且给定滑动窗口大小，窗口每次右移一位，求每次移动窗口中最大的数字
     *
     * @param a 给定数组
     * @param k 滑动窗口大小
     */
    private static int[] maxSlidingWindow(int[] a, int k) {

        // 以下情况不处理
        if (a == null || a.length == 0) {
            return null;
        }

        // 数组长度小于窗口长度 或者 窗口长度非正整数，不处理
        if (a.length < k || k <= 0) {
            return null;
        }

        // 缓存每次移动滑动窗口中的最大元素
        int[] result = new int[a.length - k + 1];

        // 双端队列存储数组元素的下标
        Deque<Integer> deque = new LinkedList<>();

        // 遍历原数组每个元素
        for (int i = 0; i < a.length; i++) {
            // 判断双端队列的尾部是否小于当前滑动窗口右移一步新增的元素，如果小于就移除双端队列尾部的元素，因为找到了比它更大的元素
            while (!deque.isEmpty() && a[deque.peekLast()] <= a[i]) {
                // 移除双端队列尾部元素
                deque.pollLast();
            }

            deque.add(i);

            // 判断双端队列的头部是否已经超出了滑动窗口的范畴，超出就要移除
            if (deque.peek() <= i - k) {
                // 弹出队首元素
                deque.poll();
            }

            // 当前已经遍历到满足滑动窗口的长度，开始取滑动窗口的最大值
            if (i + 1 >= k) {
                // 通过上面的操作，本次双端队列头部的元素一定是本次滑动窗口的最大值
                result[i - k + 1] = a[deque.peek()];    // 切记双端队列缓存的是数组下标，需要转换成元素值
            }
        }

        return result;
    }

    public static void main(String[] args) {
        int[] a1 = {1, 3, -1, -3, 5, 3, 6, 7};
        System.out.println("正确答案:" + Arrays.toString(maxSlidingWindow(a1, 3)));
        System.out.println("本次答案:" + Arrays.toString(myMaxSlidingWindow(a1, 3)));
    }
}

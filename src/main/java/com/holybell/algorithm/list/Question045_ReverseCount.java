package com.holybell.algorithm.list;

import com.holybell.algorithm.sort.Question004_MergeSort;

/**
 * 难度:中等
 * <p>
 * 求解数组中反序对的个数
 * <p>
 * 给定一个数组a，如果a[i]>a[j](i<j),那么a[i]与a[j]被称为一个反序，例如给定数组{1,5,3,2,6}，共有（5,3）、（5,2），（3,2）三个反序对。
 * 简单来说，就是前面的元素比后面的元素大，这种配对有多少对。
 */
public class Question045_ReverseCount {


    // 不考虑暴力解法，双重循环比较两个元素，有其他解法吗?

    /**
     * 判断一个数组中前面元素比后面元素大的对数
     *
     * @param a 给定数组
     */
    private static int myReverseCount(int[] a) {
        return -1;
    }


    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------

    // 使用全局变量保存反序对个数
    private static int reverseCount = 0;

    /**
     * 判断一个数组中前面元素比后面元素大的对数
     *
     * @param a 给定数组
     * @see Question004_MergeSort 本解法参考归并排序
     */
    private static int reverseCount(int[] a) {

        // 以下情况不处理
        if (a == null || a.length == 0) {
            return -1;
        }

        // 借助归并排序来计算反序对
        mergeSortHelper(a, 0, a.length - 1);

        // 处理过程反序对个数缓存到全局变量
        return reverseCount;
    }

    private static void mergeSortHelper(int[] a, int start, int end) {
        if (start < end) {
            // 计算中间值坐标
            int mid = (start + end) >>> 1;
            // 递归计算左子数组
            mergeSortHelper(a, start, mid);
            // 递归计算左子数组                这两次递归的最终就是划分到左右子数组各自只有一个元素，互相比较
            mergeSortHelper(a, mid + 1, end);
            // 比较左右子数组的大小关系
            mergeSort(a, start, mid, end);
        }
    }

    private static void mergeSort(int[] a, int start, int mid, int end) {

        // 左数组长度
        int llen = mid - start + 1;
        // 右数组长度
        int rlen = end - mid;

        // 将原数组的左右子数组元素分别填充到left、right两个临时数组
        int[] left = new int[llen];
        int[] right = new int[rlen];

        for (int i = 0; i < llen; i++) {
            left[i] = a[start + i];
        }
        for (int i = 0; i < rlen; i++) {
            right[i] = a[mid + 1 + i];
        }

        // 左右子数组两两比较，小的放回原数组
        int lpos = 0, rpos = 0;
        while (lpos < llen && rpos < rlen) {
            // 左边更小
            if (left[lpos] < right[rpos]) {
                // 左边元素放回原数组，并且原数组和做数组下标+1
                a[start++] = left[lpos++];
            } else {
                // 重要，利用归并排序的原因在此
                // 归并排序的一个重要特性就是，左右子数组各自有序，并且在放回原数组之前，左数组和右数组之间的元素 前后位置是不变的，即左边的元素一定每个都在右边元素前面，
                // 那么，此时 left[lpos] > right[rpos]，那么说明 left[lpos....mid-1] 这几个元素都大于 right[rpos]，共 （mid-lpos+1）个~~~~~！！！！
                reverseCount = reverseCount + (mid - lpos + 1);
                a[start++] = right[rpos++];
            }
        }

        // 填充左右子数组没有放回原数组的元素
        if (lpos < llen) {
            for (int i = lpos; i < llen; i++) {
                a[start++] = left[i];
            }
        }
        if (rpos < rlen) {
            for (int i = rpos; i < rlen; i++) {
                a[start++] = right[i];
            }
        }
    }

    public static void main(String[] args) {
        int a[] = {1, 5, 3, 2, 6};
        System.out.println("正确答案，反序对:" + reverseCount(a));
        reverseCount = 0;// 重置结果
        int b[] = {1, 5, 3, 2, 6};
        System.out.println("本次答案，反序对:" + myReverseCount(a));
    }
}

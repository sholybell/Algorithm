package com.holybell.algorithm.list;

/**
 * 难度：简单
 * <p>
 * 求指定数字在数组中第一次出现的位置
 * 问题描述：给定数组a={3,4,5,6,5,6,7,8,9,8},这个数组相邻元素之差都为1，
 * 给定数字9，它在数组中第一次出现的位置的下标为8（数组下标从0开始）
 */
public class Question040_FindFirstAppearIndex {

    // 遍历数组查询第一个值匹配的元素   这种解法不考虑


    /**
     * 从相邻之差为1的数组中，查询某个值第一次出现的位置
     *
     * @param a      给定数组
     * @param target 目标值
     */
    private static int myFindIndex(int[] a, int target) {
        return Integer.MIN_VALUE;
    }


    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------

    /**
     * 从相邻之差为1的数组中，查询某个值第一次出现的位置
     * <p>
     * 跳跃搜索法：
     * <p>
     * 通过对数组{3,4,5,6,5,6,7,8,9,8}中元素的特点进行分析发现如下规律：
     * 假设从数组a中查找9出现的位置，首先用数组中第一个元素（数组下标为0）3与9进行比较，它们的差值为6，
     * <p>
     * 由于数组中相邻两个元素的差值为1，因此9在数组中最早出现的位置必定为：第1+6=7个位置（数组下下标为6），
     * 这是因为：如果数组是递增的，那么数组第7个元素的值才为9，如果数组不是递增的，那么9出现的位置肯定在数组中第7个元素后面；
     * 上面的示例中待查找的数比数组中第一个元素的值大，对于待查找的数比数组中第一个元素小的情况，可以用相同的方法。
     * <p>
     * 根据这个特点可以得出算法的思路为：
     * 从数组第一个元素开始（i=0），把数组当前位置的值与t进行比较，如果相等，则返回数组下标，否则从数组下标i+|t - a[i]|处继续查找
     *
     * @param a      给定数组
     * @param target 目标值
     */
    private static int findIndex(int[] a, int target) {

        // 以下情况不处理
        if (a == null || a.length == 0) {
            return Integer.MIN_VALUE;
        }

        for (int i = 0; i < a.length; ) {
            // 找到目标值，返回下标
            if (a[i] == target) {
                return i;
            }

            // 当前位置元素值并不是目标值，继续往后查找
            // 由于数组相邻元素相差为1，无论找的数字比数组首元素大还是小，影响的只是若数组递增递减目标数字就在与首元素相差的位置，如果不在只可能再往后找
            // 不可能往回找，如果前面存在目标值，就应该遍历不到后面的元素，因为相邻元素相差1，如果不是递增，跳跃查找没找到只能说明这次查找的范围内不是递增的，存在回溯的数字！！！
            i = i + Math.abs(target-a[i]);
        }
        return Integer.MIN_VALUE;
    }


    public static void main(String[] args) {
        int a[] = {3, 4, 5, 6, 5, 6, 7, 8, 9, 8};
        System.out.println(findIndex(a, 9));
        System.out.println(myFindIndex(a, 9));
    }
}

package com.holybell.algorithm.queue;


import java.util.*;

/**
 * 难度：困难
 * <p>
 * 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。
 * 你只可以看到在滑动窗口 k 内的数字。
 * 滑动窗口每次只向右移动一位。
 * 返回滑动窗口最大值。
 * <p>
 * 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7] 解释: leetCode 239
 */
public class LeetCode239_MaxSlidingWindow {


    /**
     * @param nums 给定数组
     * @param k    窗口的长度
     */
    private static int[] myMaxSlidingWindow(int[] nums, int k) {
        return null;
    }

    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------

    private static int[] maxSlidingWindowV1(int[] nums, int k) {

        // 如果给定数组为null，或者给定数组就没有达到窗口长度返回null
        if (nums == null || nums.length < k) {
            return new int[0];
        }

        // 双端队列，存储窗口的下标
        Deque<Integer> dq = new LinkedList<>();
        // 保存最后返回的结果
        int[] results = new int[nums.length - k + 1];

        // 每一次循环代表窗口往右移动一位
        for (int i = 0; i < nums.length; i++) {

            // 队列头部存储的是上一个窗口的最大值下标
            // 每次窗口往右边移动，校验队列尾部的元素是否不大于当前元素，满足则将尾部元素弹出
            // 这里的关注点有：
            // 1. 这是个循环，如果窗口移动之后新加入的元素大于前面窗口的所有元素，那么前面队列将被清空
            // 2. 如果当前元素大于队列尾部元素，说明这个窗口的最大元素肯定不会是队列尾部元素，可以把队列尾部的元素淘汰出去
            // 3. 如果当前元素小于队列尾部的元素，队列尾部的元素是不需要弹出的，因为不知道窗口移动之后，需要加入的这个更小的元素是否会在某次移动变成窗口最大元素
            while (!dq.isEmpty() && nums[dq.peekLast()] <= nums[i]) {
                dq.pollLast();
            }

            // 将当前元素下标加入到队列尾部
            dq.addLast(i);

            // 队列首部的存储的下标是队列内部最小的(也是上次窗口中最大值的下标)，判断本次移动之后队列头部元素是否超出本窗口长度，要弹出
            if (dq.peek() <= i - k) {
                dq.poll();
            }

            // 当前遍历的下标达到了窗口长度，可以开始选择窗口内最大的元素
            if (i + 1 >= k) {
                results[i + 1 - k] = nums[dq.peek()];
            }
        }
        return results;
    }

    // -----------------------------------------------------------------------
    
    /**
     * 优先队列，利用大顶堆特性
     */
    private static int[] maxSlidingWindowV2(int[] nums, int k) {

        // 如果给定数组为null，或者给定数组就没有达到窗口长度返回null
        if (nums == null || nums.length < k) {
            return new int[0];
        }

        int n = nums.length;
        // 使用优先队列，排序规则为大顶堆，队列存储元素值和元素位置
        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {
            public int compare(int[] pair1, int[] pair2) {
                return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair2[1] - pair1[1];
            }
        });

        // 先将数组前部的元素填充到优先队列窗口中，
        for (int i = 0; i < k; ++i) {
            pq.offer(new int[]{nums[i], i});
        }

        //声明一个保存结果的数组，并保存第一组窗口内最大值
        int[] ans = new int[n - k + 1];
        ans[0] = pq.peek()[0];

        // 开始将滑动窗口向左移动，每次移动一次，如果有元素出了滑动窗口从优先队列中移除
        for (int i = k; i < n; ++i) {

            // 这个要放在下面的循环前面，因为如果滑动窗口长度为1的时候，
            // 每次往右移动一位，将会导致peek弹出超出滑动窗口的元素之后，再次peek空指针
            // 若放到循环下方也可以，需要在循环中增加判断优先队列是否为空条件
            pq.offer(new int[]{nums[i], i});

            while (pq.peek()[1] <= i - k) {
                pq.poll();
            }
            // 记录本次移动中滑动窗口中最大的元素
            ans[i - k + 1] = pq.peek()[0];
        }
        return ans;
    }

    public static void main(String[] args) {
        int[] nums1 = new int[]{1, 3, -1, -3, 5, 3, 6, 7};
        int[] nums2 = new int[]{1, -1};
        System.out.println("你的答案:" + Arrays.toString(myMaxSlidingWindow(nums1, 3)));
        System.out.println("你的答案:" + Arrays.toString(myMaxSlidingWindow(nums2, 1)));
        System.out.println("----------------------------------------->");
        System.out.println("正确答案:" + Arrays.toString(maxSlidingWindowV2(nums1, 3)));
        System.out.println("正确答案:" + Arrays.toString(maxSlidingWindowV2(nums2, 1)));
    }
}

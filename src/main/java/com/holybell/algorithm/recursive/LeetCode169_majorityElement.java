package com.holybell.algorithm.recursive;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * 难度:简单
 * <p>
 * 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
 * <p>
 * 你可以假设数组是非空的，并且给定的数组总是存在多数元素。
 * <p>
 * <p>
 * 示例 1：
 * 输入：[3,2,3]
 * 输出：3
 * <p>
 * <p>
 * 示例 2：
 * 输入：[2,2,1,1,1,2,2]
 * 输出：2
 * <p>
 * <p>
 * 进阶：
 * <p>
 * <p>
 * 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。
 * <p>
 * Related Topics 位运算 数组 分治算法
 */
public class LeetCode169_majorityElement {

    private static int myMajorityElement(int[] nums) {
        return -1;
    }

    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------

    /**
     * 注意题目，题目保证众数一定存在，那么排序之后，众数一定在数组中间位置
     */
    private static int majorityElementV1(int[] nums) {
        Arrays.sort(nums);
        return nums[nums.length / 2];
    }

    // ---------------------------------------------------------------------------

    /**
     * 遍历数组，使用一个Map记录数组中元素出现的频次
     */
    private static int majorityElementV2(int[] nums) {
        // 使用一个Map记录元素和出现频率的映射关系
        Map<Integer, Integer> countMap = new HashMap<>();

        for (int num : nums) {
            if (!countMap.containsKey(num)) {
                countMap.put(num, 1);
            } else {
                int count = countMap.get(num);
                countMap.put(num, ++count);
            }
        }

        // 遍历Map求得出现频率最大的数字
        int frequency = 0;
        int target = Integer.MIN_VALUE;
        for (Map.Entry<Integer, Integer> entry : countMap.entrySet()) {
            if (entry.getValue() > frequency) {
                target = entry.getKey();
            }

            // 如果当前元素出现次数大于数组长度/2，那么该数字就是众数
            if (entry.getValue() > nums.length / 2) {
                return entry.getKey();
            }
        }
        return target;
    }

    // ---------------------------------------------------------------------------

    /**
     * 递归解法
     */
    private static int majorityElementV3(int[] nums) {
        return helper(nums, 0, nums.length - 1);
    }

    /**
     * 如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。
     * <p>
     * 我们可以使用反证法来证明这个结论。
     * 假设 a 既不是左半部分的众数，也不是右半部分的众数，那么 a 出现的次数少于 l / 2 + r / 2 次，其中 l 和 r 分别是左半部分和右半部分的长度。
     * 由于 l / 2 + r / 2 <= (l + r) / 2，说明 a 也不是数组 nums 的众数，因此出现了矛盾。所以这个结论是正确的。
     * <p>
     * 这样以来，我们就可以使用分治法解决这个问题：将数组分成左右两部分，分别求出左半部分的众数 a1 以及右半部分的众数 a2，随后在 a1 和 a2 中选出正确的众数。
     */
    private static int helper(int[] nums, int low, int high) {

        // 如果高低指针相等，表示当前递归分治到最后只有一个元素，自己构成众数
        if (low == high) {
            return nums[low];
        }

        // 当前递归分治操作处理两个子数组
        int mid = low + (high - low) / 2;
        int left = helper(nums, low, mid);
        int right = helper(nums, mid + 1, high);
        // 如果两个子数组的众数一样，那么两个数字合并起来的众数也会是这个数字
        if (left == right) {
            return left;
        }

        int leftCount = count(nums, left, low, high);
        int rightCount = count(nums, right, low, high);
        return leftCount > rightCount ? left : right;
    }

    /**
     * 统计给定范围内数组某个元素出现频率
     *
     * @param nums   给定数组
     * @param target 目标数字
     * @param low    上界
     * @param high   下界
     */
    private static int count(int[] nums, int target, int low, int high) {
        int cnt = 0;
        for (int i = low; i <= high; i++) {
            if (nums[i] == target) {
                cnt++;
            }
        }
        return cnt;
    }

    // ---------------------------------------------------------------------------

    /**
     * 摩尔投票法
     */
    private static int majorityElementV4(int[] nums) {
        Integer candidate = null;

        // 表示投票数量
        int count = 0;

        for (int num : nums) {
            // 如果前面的投票结果为0，那么新进来的元素重新成为候选者
            if (count == 0) {
                candidate = num;
            }
            // 如果当前数字和候选人不一样，那么就投反对票，如果当前数字和候选人一样，那么投赞成票，对应为-1和+1
            count += (num == candidate) ? 1 : -1;
        }
        return candidate;
    }

    public static void main(String[] args) {
        int[] nums1 = new int[]{3, 2, 3};
        int[] nums2 = new int[]{2, 2, 1, 1, 1, 2, 2};
        System.out.println("你的答案:");
        System.out.println(Arrays.toString(nums1) + " 的众数为 : " + myMajorityElement(Arrays.copyOf(nums1, nums1.length)));
        System.out.println("----------------------------------->");
        System.out.println("正确答案:");
        System.out.println(Arrays.toString(nums1) + " 的众数为 : " + majorityElementV1(Arrays.copyOf(nums1, nums1.length)));
        System.out.println(Arrays.toString(nums2) + " 的众数为 : " + majorityElementV2(nums2));
        System.out.println(Arrays.toString(nums2) + " 的众数为 : " + majorityElementV3(nums2));
        System.out.println(Arrays.toString(nums2) + " 的众数为 : " + majorityElementV4(nums2));
    }
}

package com.holybell.algorithm.bigdata;

import java.util.BitSet;
import java.util.Random;

/**
 * 难度:中等
 * <p>
 * 在海量数据中查找处重复出现的元素或者去除重复出现的元素。
 * <p>
 * 针对此类问题，一般可以通过位图法实现，例如：已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。
 * <p>
 * 类似的题目还有:
 * <p>
 * 1.10亿个正整数，只有一个数字重复，要求在O(N)的时间里找出这个数。
 * 2.给定a，b两个文件，各存放50亿个URL，每个URL各占64Byte，要求在O（N）的时间里找出a，b文件共同的URL
 * 3.给40亿个不重复的unsigned int的整数（没排序过），然后再给一个数，如何快速判断这个数是否在那40亿个数当中。
 */
public class Question049_FindDuplicateInBigData {

    private static int mySort() {
        return Integer.MIN_VALUE;
    }


    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------


    // 本例中，采用时间作为种子，产生了100个随机数， 对着100个数进行位图法排序，进而找出其中重复的数据，与此问题相似的面试题还有:  TODO
    // 本题最好的解决方法是通过使用位图法来实现。8位整数可以表示为最大十进制数值99999999，
    // 如果每个数值对应于位图中的一个bit位，那么存储八位整数大约需要99MBit，因为1Byte=8bit，
    // 所以99MB折合成内存为99/8=12.375MB内存，即可以只用12.375MB的内存表示所有8位数电话号码内容。

    // 解法1:

    private static int ARRNUM = 100;
    // 8位号码最小值
    private static int min = 10000000;
    // 8位号码最大值
    private static int max = 99999999;

    // 计算最大值和最小值中间共有多少个数字
    private static int N = (max - min) + 1;

    // 由于一个int共32bit，这里取32
    private static int BIT_PER_WORD = 32;

    private static int WORD_OFFSET(int b) {
        return b / BIT_PER_WORD;
    }

    private static int BIT_OFFSET(int b) {
        return b % BIT_PER_WORD;
    }

    /**
     * 将逻辑位置为n的二进制位置为1
     *
     * @param words 存放数字存在状态的数字
     * @param n     要设置存在状态的数字
     */
    private static void setBit(int[] words, int n) {
        n = n - min;
        words[WORD_OFFSET(n)] |= (1 << BIT_OFFSET(n));
    }

    /**
     * 将逻辑位置为n的二进制表示为0
     *
     * @param words 存放数字存在状态的数字
     * @param n     要清除存在状态的数字
     */
    private static void clearBit(int[] words, int n) {
        words[WORD_OFFSET(n)] &= ~(1 << BIT_OFFSET(n));
    }

    /**
     * 测试逻辑位置为n的二进制位是否为1
     *
     * @param words 存放数字存在状态的数字
     * @param n     要判断是否存在的数字
     * @return
     */
    private static boolean getBit(int[] words, int n) {
        int bit = words[WORD_OFFSET(n)] & (1 << BIT_OFFSET(n));
        return bit != 0;
    }

    private static int sortV1() {

        int arr[] = new int[ARRNUM];

        // 首先将每个数字/32分摊到每个数组位置，然后再计算每个数字在当前下标位置整型对应的bit位置
        int[] words = new int[1 + N / BIT_PER_WORD];
        int count = 0;
        Random r = new Random();

        // 生成100个随机数放到数组ARR中
        for (int j = 0; j < ARRNUM; j++) {
            arr[j] = r.nextInt(N);
            arr[j] += min;
        }

        // 将生成的随机数存入words中
        for (int j = 0; j < ARRNUM; j++) {
            setBit(words, arr[j]);
        }

        // 遍历8位号码整个区间，判断是否已经存在重复值
        for (int i = 0; i < N; i++) {
            if (getBit(words, i)) {
                count++;
            }
        }

        return count;
    }

    // 解法2: 利用java提供的原生BitSet

    private static int sortV2() {

        int min = 10000000;
        int max = 99999999;
        int len = max - min + 1;

        int count = 0;

        BitSet bitSet = new BitSet(len);

        // 通过随机数随机生成8位号码区间内的100个号码
        Random r = new Random();
        for (int i = 0; i < 100; i++) {
            int num = r.nextInt(len);
            bitSet.set(min + num, true);
        }

        // 遍历所有数字，判断是否已经存在BitSet中
        for (int i = 0; i < len; i++) {
            if (bitSet.get(10000000 + i)) {
                count++;
            }
        }

        return count;
    }


    public static void main(String[] args) {
        // 由于上面解法存在随机数，因此正确答案的参考性不强，每次都是随机答案!!!!!!!
        System.out.println("正确答案:" + sortV1());
        System.out.println("正确答案:" + sortV2());
        System.out.println("--------------------->");
        System.out.println("本次答案:" + mySort());
    }

}

package com.holybell.algorithm.dp;

import java.util.Arrays;

/**
 * 给定不同面额的硬币 coins 和一个总金额 amount。
 * 编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回-1。
 * <p>
 * 你可以认为每种硬币的数量是无限的。
 * <p>
 * 难度:中等
 * <p>
 * 示例 1：
 * 输入：coins = [1, 2, 5], amount = 11
 * 输出：3
 * 解释：11 = 5 + 5 + 1
 * <p>
 * 示例 2：
 * 输入：coins = [2], amount = 3
 * 输出：-1
 * <p>
 * 示例 3：
 * 输入：coins = [1], amount = 0
 * 输出：0
 * <p>
 * 示例 4：
 * 输入：coins = [1], amount = 1
 * 输出：1
 * <p>
 * 示例 5：
 * 输入：coins = [1], amount = 2
 * 输出：2
 * <p>
 * 提示：
 * 1 <= coins.length <= 12
 * 1 <= coins[i] <= 231 - 1
 * 0 <= amount <= 104
 **/
public class LeetCode_coinChange {

    public static int _coinChange(int[] coins, int amount) {
        return -1;
    }

    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------

    /**
     * 给定一个硬币集合，求各种硬币组合达到amount的最少硬币数
     *
     * @param coins  硬币面值集合
     * @param amount 给定数量
     */
    private static int coinChange(int[] coins, int amount) {
        // 使用一个数组来保存达到当前下标的amount至少需要多少硬币
        int[] dp = new int[amount + 1];
        // 将数组的元素全部初始化为amount+1,因为硬币最小为1，那么达到amount最大硬币数量就是amount，amount+1是一个不可能值（注意题目的给定的数值范围）
        Arrays.fill(dp, amount + 1);
        // amount=0时，很明显，只需要0个硬币
        dp[0] = 0;
        // 开始计算每个amount需要的最少硬币数量
        for (int i = 1; i <= amount; i++) {
            for (int coin : coins) {
                // 当前amount采用这枚币值的硬币之后会超过amount本身，不采用
                if (i - coin < 0) {
                    continue;
                }
                // 每一个amount的最少硬币数都可以考虑成这种情况，（当前amount-各种硬币的币值）这个比较小的amount+当前币值1个，得到一个当前amount可能的最少硬币数量
                // dp[i]会再循环中不断地被覆盖，因此每次都需要再拿出来和dp[i-coin]比较
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
        return dp[amount] == amount + 1 ? -1 : dp[amount];
    }


    public static void main(String[] args) {
        int[] coins = new int[]{1, 2, 5};
        int amount = 11;
        System.out.println("你的答案:");
        int result = _coinChange(coins, amount);
        System.out.println(result);
        System.out.println("---------------------------->");
        System.out.println("正确答案:");
        result = coinChange(coins, amount);
        System.out.println(result);
    }
}

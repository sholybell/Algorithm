package com.holybell.algorithm.dp;

/**
 * 难度:困难
 * <p>
 * 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
 * 你可以对一个单词进行如下三种操作：
 * 插入一个字符
 * 删除一个字符
 * 替换一个字符
 * <p>
 * <p>
 * 示例 1：
 * 输入：word1 = "horse", word2 = "ros"
 * 输出：3
 * 解释：
 * horse -> rorse (将 'h' 替换为 'r')
 * rorse -> rose (删除 'r')
 * rose -> ros (删除 'e')
 * <p>
 * <p>
 * 示例 2：
 * 输入：word1 = "intention", word2 = "execution"
 * 输出：5
 * 解释：
 * intention -> inention (删除 't')
 * inention -> enention (将 'i' 替换为 'e')
 * enention -> exention (将 'n' 替换为 'x')
 * exention -> exection (将 'n' 替换为 'c')
 * exection -> execution (插入 'u')
 * <p>
 * <p>
 * 提示：
 * 0 <= word1.length, word2.length <= 500
 * word1 和 word2 由小写英文字母组成
 * <p>
 * Related Topics 字符串 动态规划
 */
public class LeetCode72_minDistance {

    private static int myMinDistance(String word1, String word2) {
        return -1;
    }

    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------
    // --------------------------------------------------------------------

    /**
     * 要理解本动态规划解法首先要明白：
     * ①对于字符串abc和字符串ab，可以删除abc后面的c，也可以在ab后面添加c，因此其实在一个字符串后面删除一个字符和在另一个字符串后面添加一个字符意义一样
     * 所以本题三种操作可以简化为：
     * 1. 在字符串abc和ab两个字符串中，ab后面添加c  (字符串1为abc，字符串2为ab)
     * 2. 在字符串ab和abc两个字符串中，ab后面添加c  (字符串1为ab，字符串2为abc)
     * 3. 在字符串abc和abd两个字符串中，随便替换其中一个字符串第三个字母比如abc的c变为d，或者abd中的d变为c
     * <p>
     * 那么以上思路该如何应用到解题方法中呢？
     * <p>
     * 我们可以将字符串word1和字符串word2看成一个个字符串，如：
     * word1 可以看成 "",w,wo,wor,word,word1  ""表示空字符串
     * word2 可以看成 "",w,wo,wor,word,word2  ""表示空字符串
     * <p>
     * 分析可能的情况，以i表示字符串1的字符位置，j表示字符串2的字符位置：
     * <p>
     * (使用DP[i][j]表示字符串1前i个元素到字符串2前j个元素的最短编辑近距离)
     * <p>
     * 情况1 : 字符串1取wd时(i=2)，字符串2取wo(j=2)，那么可以考虑在字符串1的i-1位置后面添加o变成wod，此时保证了字符串1(wod)前i个字符和字符串2(wo)前j个字符一致
     * 情况2 : 字符串1取wd时(i=2)，字符串2取wo(j=2)，那么可以考虑在字符串2的j-1位置后面添加d变成wdo，此时保证了字符串1(wd)前i个字符和字符串2(wdo)前j个字符一致
     * 情况3 : 字符串1取wd时(i=2)，字符串2取wo(j=2)，那么可以考虑替换字符串1的i位置或者字符串2的j位置，比如替换字符串1的i位置为o，此时保证了字符串1(wo)前i个字符和字符串2(wo)前j个字符一致
     * 情况3 : 字符串1取wo时(i=2)，字符串2取wo(j=2)，刚好字符串1和字符串2的i、j位置字符一样，不用做替换
     */
    private static int minDistance(String word1, String word2) {

        int n1 = word1.length(), n2 = word2.length();

        if (n1 * n2 == 0) {
            return n1 + n2;     // n1、n2各自为0，或者都为0
        }

        // 第一维度表示第一个字符串的每一个字符位置，包括空字符串，0 - word1.length，第二维度表示第二个字符串相同关系
        // dp[i][j]表示 第一个字符串0-i子串到第二个字符串0-j 的最短编辑距离
        int[][] dp = new int[n1 + 1][n2 + 1];

        // 当其中一个字符串为空字符串(由下标0表示)，那么另一个非空字符串到每一个字符所需要的操作就是删除，因此第几个字符就操作几次删除
        // 也可以理解为空字符串要到第几个字符要补充几个字符
        for (int i = 0; i <= n1; i++) {
            dp[i][0] = i;
        }
        for (int i = 0; i <= n2; i++) {
            dp[0][i] = i;
        }

        for (int i = 1; i <= n1; i++) {
            for (int j = 1; j <= n2; j++) {
                // 注释中的情况1，在第一个字符串前面i-1位置后添加字符
                int a = dp[i - 1][j] + 1;
                // 注释中的情况2，在第二个字符串前面i-1位置后添加字符
                int b = dp[i][j - 1] + 1;
                // 注释中的情况4，此时i和j相等不需额外操作
                int c = dp[i - 1][j - 1];
                // 注释中的情况3，此时i和j不相等，需要替换其中一个字符串的当前字符
                if (word1.charAt(i - 1) != word2.charAt(j - 1)) {
                    c = c + 1;
                }
                // 以上操作选取操作次数最少的记录字符串1的i位置到字符串2的j位置最短编辑距离
                dp[i][j] = Math.min(a, Math.min(b, c));
            }
        }

        return dp[n1][n2];
    }

    public static void main(String[] args) {
        String word1 = "horse", word2 = "ros", word3 = "intention", word4 = "execution";
        System.out.println("你的答案:");
        System.out.println(word1 + " 和 " + word2 + " 的最小编辑距离为 : " + myMinDistance(word1, word2));
        System.out.println(word3 + " 和 " + word4 + " 的最小编辑距离为 : " + myMinDistance(word3, word4));
        System.out.println("------------------------------>");
        System.out.println("正确答案:");
        System.out.println(word1 + " 和 " + word2 + " 的最小编辑距离为 : " + minDistance(word1, word2));
        System.out.println(word3 + " 和 " + word4 + " 的最小编辑距离为 : " + minDistance(word3, word4));
    }
}

package com.holybell.algorithm.dp.knapsack_problem.complete_knapsack;

import java.util.Arrays;

/**
 * 完全背包问题
 * <p>
 * 相关题目：
 * com.holybell.algorithm.dp.knapsack_problem.*  本包下所有题目都是背包问题变种
 * <p>
 * 参考:https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-shi-yong-wan-quan-bei-bao-wen-ti-/
 * <p>
 * [0-1背包问题]：
 * 状态转移方程 ： dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+v[i])
 * 因为只关心最后一行最后一格数值，每个单元格只参考它上一行，并且是正上方以及正上方左边的单元格数值
 * <p>
 * [完全背包问题]:
 * 状态转移方程 :  dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]]+v[i])
 * 「完全背包」问题压缩成一行的写法，正好与「0-1 背包」问题相反，「0-1 背包」问题倒着写，「完全背包」问题正着写（看看填表顺序，就明白了）
 */
public class CompletedKnapsnackProblem {

    // ------------------------------------------  完全背包问题（物品有0-无限次放置次数）  -------------------------------------------

    /**
     * 有N件物品和一个容量是V的背包。每件物品只能使用一次，每种物品都有无限件可用。
     * 第i件物品的体积是w[i],价值是v[i]。
     * 求将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。
     * <p>
     * 分析:
     * 「完全背包问题」的重点在于
     * 每种物品都有无限件可用；
     * 一个元素可以使用多个，且不计算顺序。
     * <p>
     * 状态定义:
     * dp[i][j] 表示考虑物品区间 [0, i] 里，不超过背包容量，能够获得的最大价值
     * 状态转移方程 : dp[i][j] = max( dp[i−1][j] , dp[i−1][j − k * w[i]] + k * v[i])   (k>=0)
     *
     * @param W      背包最大能够装的重量
     * @param N      提供的物品数量
     * @param weight 物品的重量集合
     * @param value  物品的价值集合
     */
    public static void knapsnackV1(int W, int N, int[] weight, int[] value) {

        // dp[i][j] 表示考虑物品区间 [0, i] 里，不超过背包容量，能够获得的最大价值；
        // 因为包含价值为 0 的计算，所以 + 1
        int[][] dp = new int[N][W + 1];

        // 先写第 1 行
        for (int k = 0; k * weight[0] <= W; k++) {
            dp[0][k * weight[0]] = k * value[0];
        }

        // 最朴素的做法

        // 第一行，列举每个物品在每个最大容量的情况下可以选取的最大个数，以及个数下的最大价值
        for (int i = 1; i < N; i++) {
            // 限制最大重量
            for (int j = 0; j <= W; j++) {
                // 多一个 for 循环，枚举下标为 i 的物品可以选的个数
                for (int k = 0; k * weight[i] <= j; k++) {
//                    System.out.println("dp[" + i + "][" + j + "] = Math.max(dp[" + i + "][" + j + "], dp[" + (i - 1) + "][" + j + " - " + k + " * weight[" + i + "]] + " + k + " * value[" + i + "]) = Math.max(dp[" + i + "][" + j + "], dp[" + (i - 1) + "][" + (j - k * weight[i]) + "] + " + (k * value[i]) + ") = Math.max(" + dp[i][j] + ", " + dp[i - 1][j - k * weight[i]] + " + " + (k * value[i]) + ")");
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - k * weight[i]] + k * value[i]);
                }
            }
        }

        // ArrayUtil.printBoard(dp);  输出此时的DP二维网格
        // W=4
        // weight = {2, 1, 3};
        // value = {4, 2, 3};
        // 最大重量:      0  1  2  3  4
        // 物品1可选     [0, 0, 4, 0, 8]   --------> 同一行越往右边dp值越大
        // 物品2可选     [0, 2, 4, 6, 8]   |
        // 物品3可选     [0, 2, 4, 6, 8]   |         同一列越往下dp值越大

        //                              dp[i-1][j - k*weight[i]] + k*value[i]   j >> 0 >> W
        //dp[1][0] = Math.max(dp[1][0], dp[0][0 - 0 * weight[1]] + 0 * value[1]) = Math.max(dp[1][0], dp[0][0] + 0) = Math.max(0, 0 + 0)

        //dp[1][1] = Math.max(dp[1][1], dp[0][1 - 0 * weight[1]] + 0 * value[1]) = Math.max(dp[1][1], dp[0][1] + 0) = Math.max(0, 0 + 0)
        //dp[1][1] = Math.max(dp[1][1], dp[0][1 - 1 * weight[1]] + 1 * value[1]) = Math.max(dp[1][1], dp[0][0] + 2) = Math.max(0, 0 + 2)

        //dp[1][2] = Math.max(dp[1][2], dp[0][2 - 0 * weight[1]] + 0 * value[1]) = Math.max(dp[1][2], dp[0][2] + 0) = Math.max(0, 4 + 0)
        //dp[1][2] = Math.max(dp[1][2], dp[0][2 - 1 * weight[1]] + 1 * value[1]) = Math.max(dp[1][2], dp[0][1] + 2) = Math.max(4, 0 + 2)
        //dp[1][2] = Math.max(dp[1][2], dp[0][2 - 2 * weight[1]] + 2 * value[1]) = Math.max(dp[1][2], dp[0][0] + 4) = Math.max(4, 0 + 4)

        //dp[1][3] = Math.max(dp[1][3], dp[0][3 - 0 * weight[1]] + 0 * value[1]) = Math.max(dp[1][3], dp[0][3] + 0) = Math.max(0, 0 + 0)
        //dp[1][3] = Math.max(dp[1][3], dp[0][3 - 1 * weight[1]] + 1 * value[1]) = Math.max(dp[1][3], dp[0][2] + 2) = Math.max(0, 4 + 2)
        //dp[1][3] = Math.max(dp[1][3], dp[0][3 - 2 * weight[1]] + 2 * value[1]) = Math.max(dp[1][3], dp[0][1] + 4) = Math.max(6, 0 + 4)
        //dp[1][3] = Math.max(dp[1][3], dp[0][3 - 3 * weight[1]] + 3 * value[1]) = Math.max(dp[1][3], dp[0][0] + 6) = Math.max(6, 0 + 6)

        //dp[1][4] = Math.max(dp[1][4], dp[0][4 - 0 * weight[1]] + 0 * value[1]) = Math.max(dp[1][4], dp[0][4] + 0) = Math.max(0, 8 + 0)
        //dp[1][4] = Math.max(dp[1][4], dp[0][4 - 1 * weight[1]] + 1 * value[1]) = Math.max(dp[1][4], dp[0][3] + 2) = Math.max(8, 0 + 2)
        //dp[1][4] = Math.max(dp[1][4], dp[0][4 - 2 * weight[1]] + 2 * value[1]) = Math.max(dp[1][4], dp[0][2] + 4) = Math.max(8, 4 + 4)
        //dp[1][4] = Math.max(dp[1][4], dp[0][4 - 3 * weight[1]] + 3 * value[1]) = Math.max(dp[1][4], dp[0][1] + 6) = Math.max(8, 0 + 6)
        //dp[1][4] = Math.max(dp[1][4], dp[0][4 - 4 * weight[1]] + 4 * value[1]) = Math.max(dp[1][4], dp[0][0] + 8) = Math.max(8, 0 + 8)

        //dp[2][0] = Math.max(dp[2][0], dp[1][0 - 0 * weight[2]] + 0 * value[2]) = Math.max(dp[2][0], dp[1][0] + 0) = Math.max(0, 0 + 0)

        //dp[2][1] = Math.max(dp[2][1], dp[1][1 - 0 * weight[2]] + 0 * value[2]) = Math.max(dp[2][1], dp[1][1] + 0) = Math.max(0, 2 + 0)
        //dp[2][2] = Math.max(dp[2][2], dp[1][2 - 0 * weight[2]] + 0 * value[2]) = Math.max(dp[2][2], dp[1][2] + 0) = Math.max(0, 4 + 0)

        //dp[2][3] = Math.max(dp[2][3], dp[1][3 - 0 * weight[2]] + 0 * value[2]) = Math.max(dp[2][3], dp[1][3] + 0) = Math.max(0, 6 + 0)
        //dp[2][3] = Math.max(dp[2][3], dp[1][3 - 1 * weight[2]] + 1 * value[2]) = Math.max(dp[2][3], dp[1][0] + 3) = Math.max(6, 0 + 3)

        //dp[2][4] = Math.max(dp[2][4], dp[1][4 - 0 * weight[2]] + 0 * value[2]) = Math.max(dp[2][4], dp[1][4] + 0) = Math.max(0, 8 + 0)
        //dp[2][4] = Math.max(dp[2][4], dp[1][4 - 1 * weight[2]] + 1 * value[2]) = Math.max(dp[2][4], dp[1][1] + 3) = Math.max(8, 2 + 3)

        // 二维网格变动如下:

        //  ---> dp[0][]

        // 先单独处理物品1 (重量2，价值4) ，在最大重量[0,4]的情况下，第一行如下:
        // [0, 0, 4, 0, 8]

        //  ---> dp[1][]

        // 接着处理物品2 (重量1，价值2)，最大重量仍然为[0,4]，结合第一行处理如下:
        // 第二行初始 [0, 0, 0, 0, 0]

        // 最大重量0时，无法放置此时价值0,dp[1][0]=0
        // 第二行此时 [0, 0, 0, 0, 0]

        // 最大重量1时，若选择0个物品2(即组合中仅有物品1)，那么dp[1][1]=dp[0][1]= 0，
        // 若选择1件物品2，那么dp[1][1]=dp[0][1-1](表示在物品1最大重量结果-1个物品2重量:1) + 2(1个物品2价值) = 2，终止，选最大值2
        // 第二行此时 [0, 2, 0, 0, 0]

        // 最大重量2时，若选择0个物品2(即组合中仅有物品1)，那么dp[1][2]=dp[0][2]=4，
        // 若选择1件物品2，那么dp[1][2]=dp[0][2-1](表示在物品1最大重量结果-1个物品2重量:1) + 2(1个物品2价值) = dp[0][1] + 2 = 0 + 2 = 2，
        // 若选择2件物品2，那么dp[1][2]=dp[0][2-2](表示在物品1最大重量结果-2个物品2重量:2) + 4(2个物品2价值) = dp[0][0] + 4 = 0 + 4 = 4，终止，选最大值4
        // 第二行此时 [0, 2, 4, 0, 0]

        // 最大重量3时，若选择0个物品2(即组合中仅有物品1)，那么dp[1][3]=dp[0][3]=0，
        // 若选择1件物品2，那么dp[1][3]=dp[0][3-1](表示在物品1最大重量结果-1个物品2重量:1) + 2(1个物品2价值) = dp[0][2] + 2 = 4 + 2 = 6，
        // 若选择2件物品2，那么dp[1][3]=dp[0][3-2](表示在物品1最大重量结果-2个物品2重量:2) + 4(2个物品2价值) = dp[0][1] + 4 = 0 + 4 = 4，
        // 若选择3件物品2，那么dp[1][3]=dp[0][3-3](表示在物品1最大重量结果-3个物品2重量:2) + 6(3个物品2价值) = dp[0][0] + 6 = 0 + 6 = 6，终止，选最大值6
        // 第二行此时 [0, 2, 4, 6, 0]

        // 最大重量4时，若选择0个物品2(即组合中仅有物品1)，那么dp[1][4]=dp[0][4]=8，
        // 若选择1件物品2，那么dp[1][4]=dp[0][4-1](表示在物品1最大重量结果-1个物品2重量:1) + 2(1个物品2价值) = dp[0][3] + 2 = 0 + 2 = 2，
        // 若选择2件物品2，那么dp[1][4]=dp[0][4-2](表示在物品1最大重量结果-2个物品2重量:2) + 4(2个物品2价值) = dp[0][2] + 4 = 4 + 4 = 8，
        // 若选择3件物品2，那么dp[1][3]=dp[0][4-3](表示在物品1最大重量结果-3个物品2重量:2) + 6(3个物品2价值) = dp[0][1] + 6 = 0 + 6 = 6，
        // 若选择4件物品2，那么dp[1][3]=dp[0][4-4](表示在物品1最大重量结果-4个物品2重量:2) + 8(4个物品2价值) = dp[0][0] + 6 = 0 + 8 = 8，终止，选最大值8
        // 第二行此时 [0, 2, 4, 6, 8]

        //  ---> dp[2][]

        // 接着处理物品3 (重量3，价值3)，最大重量仍然为[0,4]，结合第2行处理如下:
        // 第三行初始 [0, 0, 0, 0, 0]

        // 最大重量0时，无法放置此时价值0,dp[2][0]=0
        // 第三行此时 [0, 0, 0, 0, 0]

        // 最大重量1时，若选择0个物品3(即组合中仅有物品1\2)，那么dp[2][1]=dp[1][1]= 2，
        // 若选择1件物品3，超过最大重量无解，终止，选最大值2
        // 第三行此时 [0, 2, 0, 0, 0]

        // 最大重量2时，若选择0个物品3(即组合中仅有物品1\2)，那么dp[2][2]=dp[1][2]= 4，
        // 若选择1件物品3，超过最大重量无解，终止，选最大值4
        // 第三行此时 [0, 2, 4, 0, 0]

        // 最大重量3时，若选择0个物品3(即组合中仅有物品1\2)，那么dp[2][3]=dp[1][3]= 6，
        // 若选择1件物品3，那么dp[2][3]=dp[0][3-3](表示在物品1\2最大重量结果-1个物品3重量:3) + 3(1个物品3价值) = dp[0][0] + 3 = 0 + 3 = 3，终止，选最大值6
        // 第三行此时 [0, 2, 4, 6, 0]

        // 最大重量4时，若选择0个物品3(即组合中仅有物品1\2)，那么dp[2][4]=dp[1][4]= 8，
        // 若选择1件物品3，那么dp[2][3]=dp[0][3-3](表示在物品1\2最大重量结果-1个物品3重量:3) + 3(1个物品3价值) = dp[0][0] + 3 = 0 + 3 = 3，
        // 若选择2件物品3，超重无解，终止，选最大值8
        // 第三行此时 [0, 2, 4, 6, 8]

        // 输出
        System.out.println(dp[N - 1][W]);
    }

    /**
     * 优化「状态转移方程」（重点）
     * <p>
     * 状态定义：dp[i][j] = max(dp[i - 1][j - k * w[i]] + k * v[i]) (k >= 0) ①
     * <p>
     * 单独把 k = 0 拿出来，作为一个 max 的比较项 : 此时dp[i][j]=dp[i-1][j] ，固有如下比较
     * <p>
     * dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * w[i]] + k * v[i])，这里 k >= 1。 ②
     * <p>
     * 而当 k >= 1 的时候，把 v[i] 单独拿出来。
     * <p>
     * max(dp[i - 1][j - k * w[i]] + k * v[i]) = v[i] + max(dp[i - 1][j - k * w[i]] + (k - 1) * v[i]) ③
     * <p>
     * 将 ① 中左边的 j 用 j - w[k] 代入：
     * <p>
     * dp[i][j - w[i]] = max(dp[i - 1][j - w[i] - k · w[i]] + k · v[i])，这里 k >= 0。
     * = max(dp[i - 1][j - (k + 1)· w[i]] + k · v[i])，这里 k >= 0。
     * = max(dp[i - 1][j - k· w[i]] + (k - 1) · v[i])，这里 k >= 1。④
     * <p>
     * 结合 ②、③ 和 ④，推出 dp[i][j] = max(dp[i - 1][j], dp[i][j - w[i]]) + v[i]。
     *
     * @param W      背包最大能够装的重量
     * @param N      提供的物品数量
     * @param weight 物品的重量集合
     * @param value  物品的价值集合
     */
    public static void knapsnackV2(int W, int N, int[] weight, int[] value) {

        // dp[i][j] 表示考虑物品区间 [0, i] 里，不超过背包容量，能够获得的最大价值；
        // 因为包含价值为 0 的计算，所以 + 1
        int[][] dp = new int[N + 1][W + 1];

        // 优化

        //  一个个物品穷举
        for (int i = 1; i <= N; i++) {
            // 最大重量慢慢增大
            for (int j = 0; j <= W; j++) {
                // 至少是上一行抄下来  --->  dp[i][j]至少应该是dp[i-1][j]的值
                dp[i][j] = dp[i - 1][j];
                if (j - weight[i - 1] >= 0) {
//                    System.out.println("dp[" + i + "][" + j + "] = Math.max(dp[" + i + "][" + j + "], dp[" + i + "][" + j + " - weight[" + i + " - 1]] + value[" + i + " - 1]) = Math.max(dp[" + i + "][" + j + "], dp[" + i + "][" + (j - weight[i - 1]) + "] + " + (value[i - 1]) + ") = Math.max(" + dp[i][j] + ", " + dp[i][j - weight[i - 1]] + " + " + value[i - 1] + ")");
                    dp[i][j] = Math.max(dp[i][j], dp[i][j - weight[i - 1]] + value[i - 1]);

                    // v1版本   TODO v1版本中需要和上一行比较，v2版本仅需要和本行比较
//                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - k * weight[i]] + k * value[i]);
                }
            }
        }

        // ArrayUtil.printBoard(dp);  // 输出此时的DP二维网格
        // W=4
        // weight = {2, 1, 3};
        // value = {4, 2, 3};
        //
        //  0  1  2  3  4  最大重量
        // [0, 0, 0, 0, 0]
        // [0, 0, 4, 4, 8]
        // [0, 2, 4, 6, 8]
        // [0, 2, 4, 6, 8]      观察可以发现同一行越靠右，同一列越靠下值越大

        //                              dp[i][j - weight[i - 1]] + value[i - 1]
        //dp[1][2] = Math.max(dp[1][2], dp[1][2 - weight[1 - 1]] + value[1 - 1]) = Math.max(dp[1][2], dp[1][0] + 4) = Math.max(0, 0 + 4)
        //dp[1][3] = Math.max(dp[1][3], dp[1][3 - weight[1 - 1]] + value[1 - 1]) = Math.max(dp[1][3], dp[1][1] + 4) = Math.max(0, 0 + 4)
        //dp[1][4] = Math.max(dp[1][4], dp[1][4 - weight[1 - 1]] + value[1 - 1]) = Math.max(dp[1][4], dp[1][2] + 4) = Math.max(0, 4 + 4)

        //dp[2][1] = Math.max(dp[2][1], dp[2][1 - weight[2 - 1]] + value[2 - 1]) = Math.max(dp[2][1], dp[2][0] + 2) = Math.max(0, 0 + 2)
        //dp[2][2] = Math.max(dp[2][2], dp[2][2 - weight[2 - 1]] + value[2 - 1]) = Math.max(dp[2][2], dp[2][1] + 2) = Math.max(4, 2 + 2)
        //dp[2][3] = Math.max(dp[2][3], dp[2][3 - weight[2 - 1]] + value[2 - 1]) = Math.max(dp[2][3], dp[2][2] + 2) = Math.max(4, 4 + 2)
        //dp[2][4] = Math.max(dp[2][4], dp[2][4 - weight[2 - 1]] + value[2 - 1]) = Math.max(dp[2][4], dp[2][3] + 2) = Math.max(8, 6 + 2)

        //dp[3][3] = Math.max(dp[3][3], dp[3][3 - weight[3 - 1]] + value[3 - 1]) = Math.max(dp[3][3], dp[3][0] + 3) = Math.max(6, 0 + 3)
        //dp[3][4] = Math.max(dp[3][4], dp[3][4 - weight[3 - 1]] + value[3 - 1]) = Math.max(dp[3][4], dp[3][1] + 3) = Math.max(8, 2 + 3)

        // 二维网格变动情况:

        // 第一行:
        // 初始值: [0, 0, 0, 0, 0]

        // ---

        // 第二行:
        // 初始值: [0, 0, 0, 0, 0]

        // 物品1  重量2 价值4

        // 最大重量0，先取的上一行同一列值，dp[1][0]=dp[0][0]=0
        // 选取物品1数量无解，取最大值 0
        // 第二行此时 [(0), 0, 0, 0, 0]

        // 最大重量1，先取的上一行同一列值 dp[1][1]=dp[0][1]=0
        // 选取物品1数量无解，取最大值 0
        // 第二行此时 [0, (0), 0, 0, 0]

        // 最大重量2，先取的上一行同一列值 dp[1][2]=dp[0][2]=0
        // 可选取物品1数量1个，那么dp[1][2]=dp[1][2-2](可选取1个物品1重量:2) + 4(1个物品1价值，此时选取1个物品1) = dp[1][0] + 4 = 0 + 4 = 4，终止，取最大值 4
        // 第二行此时 [0, 0, (4), 0, 0]

        // 最大重量3，先取的上一行同一列值 dp[1][3]=dp[0][3]=0
        // 可选取物品1数量1个，那么dp[1][3]=dp[1][3-2](可选1个物品1重量:2) + 4(1个物品1价值，此时选取1个物品1) = dp[1][1] + 4 = 0 + 4 = 4，终止，取最大值 4
        // 第二行此时 [0, 0, 4, (4), 0]

        // 最大重量4，先取的上一行同一列值 dp[1][4]=dp[0][4]=0
        // 可选取物品1数量2个，那么dp[1][4]=dp[1][4-2](可选1个物品1重量:2) + 4(1个物品1价值，此时选取2个物品1) = dp[1][2] + 4 = 4 + 4 = 8，终止，取最大值 8
        // 第二行此时 [0, 0, 4, 4, (8)]

        //  -----

        // 第三行:
        // 初始值: [0, 0, 0, 0, 0]

        // 物品2  重量1 价值2

        // 最大重量0，先取的上一行同一列值，dp[2][0]=dp[1][0]=0
        // 选取物品2数量无解，取最大值 0
        // 第三行此时 [(0), 0, 0, 0, 0]

        // 最大重量1，先取的上一行同一列值 dp[2][1]=dp[1][1]=0
        // 可选取物品2数量1个，那么dp[2][1]=dp[2][1-1](可选1个物品2重量:1) + 2(1个物品2价值，此时选取1个物品2) = dp[2][0] + 2 = 0 + 2 = 2，终止，取最大值 2
        // 第二行此时 [0, (2), 0, 0, 0]

        // 最大重量2，先取的上一行同一列值 dp[2][2]=dp[1][2]=4
        // 可选取物品2数量1个，那么dp[2][2]=dp[2][2-1](可选1个物品2重量:1) + 2(1个物品2价值，此时选取2个物品2) = dp[2][1] + 2 = 2 + 2 = 4，终止，取最大值 4
        // 第二行此时 [0, 2, (4), 0, 0]

        // 最大重量3，先取的上一行同一列值 dp[2][3]=dp[1][3]=4
        // 可选取物品2数量1个，那么dp[2][3]=dp[2][3-1](可选1个物品2重量:1) + 2(1个物品2价值，此时选取3个物品2) = dp[2][2] + 2 = 4 + 2 = 6，终止，取最大值 6
        // 第二行此时 [0, 2, 4, (6), 0]

        // 最大重量4，先取的上一行同一列值 dp[2][4]=dp[1][4]=8
        // 可选取物品2数量1个，那么dp[2][4]=dp[2][4-1](可选1个物品2重量:1) + 2(1个物品2价值，此时选取3个物品2) = dp[2][3] + 2 = 6 + 2 = 6，终止，取最大值 8
        // 第二行此时 [0, 2, 4, 6, (8)]

        //  -----

        // 第四行:
        // 初始值: [0, 0, 0, 0, 0]

        // 物品2  重量3 价值3

        // 最大重量0，先取的上一行同一列值，dp[3][0]=dp[2][0]=0
        // 选取物品3数量无解，取最大值 0
        // 第四行此时 [(0), 0, 0, 0, 0]

        // 最大重量1，先取的上一行同一列值 dp[3][1]=dp[2][1]=2
        // 可选取物品3数量无解，取最大值 2
        // 第四行此时 [0, (2), 4, 0, 0]

        // 最大重量2，先取的上一行同一列值 dp[3][2]=dp[2][2]=4
        // 可选取物品3数量无解，取最大值 4
        // 第四行此时 [0, 2, (4), 0, 0]

        // 最大重量3，先取的上一行同一列值 dp[3][3]=dp[2][3]=6
        // 可选取物品3数量1个，那么dp[3][3]=dp[3][3-3](可选1个物品3重量:3) + 3(1个物品3价值，此时选取1个物品3) = dp[3][0] + 3 = 0 + 3 = 3，终止，取最大值 6
        // 第四行此时 [0, 2, 4, (6), 0]

        // 最大重量4，先取的上一行同一列值 dp[3][4]=dp[2][4]=8
        // 可选取物品3数量1个，那么dp[3][3]=dp[3][4-3](可选1个物品3重量:3) + 2(1个物品3价值，此时选取1个物品3) = dp[3][1] + 3 = 0 + 3 = 3，终止，取最大值 8
        // 第四行此时 [0, 2, 4, 6, (8)]


        // 总结:

        // 输出
        System.out.println(dp[N][W]);
    }

    /**
     * @param W      背包最大能够装的重量
     * @param N      提供的物品数量
     * @param weight 物品的重量集合
     * @param value  物品的价值集合
     */
    public static void knapsnackV3(int W, int N, int[] weight, int[] value) {

        int[] dp = new int[W + 1];

        // 优化空间
        for (int i = 1; i <= N; i++) {
            // 细节，j 从 weight[i - 1] 开始遍历
            for (int j = weight[i - 1]; j <= W; j++) {
//                System.out.println("dp[" + j + "] = Math.max(dp[" + j + "], dp[" + j + " - weight[" + i + " - 1]] + value[" + i + " - 1]) = Math.max(dp[" + j + "], dp[" + j + " - " + weight[i - 1] + "] + " + value[i - 1] + ") = Math.max(" + dp[j] + ", " + (dp[j - weight[i - 1]] + value[i - 1]) + ") = " + Math.max(dp[j], dp[j - weight[i - 1]] + value[i - 1]));
                dp[j] = Math.max(dp[j], dp[j - weight[i - 1]] + value[i - 1]);
//                System.out.println(Arrays.toString(dp));
                // TODO v2版本
                //  dp[i][j] = Math.max(dp[i][j], dp[i][j - weight[i - 1]] + value[i - 1]);
            }
//            System.out.println("---------------------------");
        }

        // 一维数组：
        // [0, 2, 4, 6, 8]

        // W=4
        // weight = {2, 1, 3};
        // value = {4, 2, 3};

        // 初始DP = [0, 0, 0, 0, 0]

        // 物品1 重量2 价值4

        // 最大重量2: dp[2] = max(dp[2],dp[2-2]+4)=max(dp[2],dp[0]+4)=max(0,0+4)=4   TODO dp[0]=0
        // [0, 0, (4), 0, 0]
        // 最大重量3: dp[3] = max(dp[3],dp[3-2]+4)=max(dp[2],dp[1]+4)=max(0,0+4)=4
        // [0, 0, 4, (4), 0]
        // 最大重量3: dp[4] = max(dp[3],dp[4-2]+4)=max(dp[2],dp[2]+4)=max(0,4+4)=8
        // [0, 0, 4, 4, (8)]

        // 物品2 重量1 价值2

        // 最大重量1: dp[1] = max(dp[1],dp[1-1]+2)=max(dp[1],dp[0]+2)=max(0,0+2)=2   TODO dp[0]=0
        // [0, (2), 4, 4, 8]
        // 最大重量2: dp[2] = max(dp[2],dp[2-1]+2)=max(dp[2],dp[1]+2)=max(4,2+2)=4
        // [0, 2, (4), 4, 8]
        // 最大重量3: dp[3] = max(dp[3],dp[3-1]+2)=max(dp[3],dp[2]+2)=max(4,4+2)=6
        // [0, 2, 4, (6), 8]
        // 最大重量4: dp[4] = max(dp[4],dp[4-1]+2)=max(dp[4],dp[3]+2)=max(8,6+2)=8
        // [0, 2, 4, 6, (8)]

        // 物品3 重量3 价值3

        // 最大重量3: dp[3] = max(dp[3],dp[3-3]+3)=max(dp[3],dp[0]+3)=max(6,0+3)=6   TODO dp[0]=0
        // [0, 2, 4, (6), 8]
        // 最大重量4: dp[4] = max(dp[4],dp[4-3]+3)=max(dp[4],dp[1]+3)=max(8,2+3)=8
        // [0, 2, 4, 6, (8)]


        // 输出
        System.out.println(dp[W]);
    }


    // ------------------------------------------  0-1背包问题（物品有0-1放置次数）  -------------------------------------------

    public static void main(String[] args) {
        int[] wt = new int[]{2, 1, 3};
        int[] val = new int[]{4, 2, 3};
//        knapsnackV1(4, wt.length, wt, val);
//        knapsnackV2(4, wt.length, wt, val);
//        knapsnackV3(4, wt.length, wt, val);
    }
}
